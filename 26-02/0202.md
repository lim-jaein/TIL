# Spring `@Transactional`

## 어노테이션이 없다면?

`PlatformTransactionManager`를 통해 try-catch 문 안에서 commit/rollback 직접 구현

이렇게 구현하면 반복되는 코드가 많다

그래서 `@Transactional` 을 사용하는 선언적인 방식이 나오게됨

## `@Transactional` 동작 원리

![image.png](attachment:e610a3c5-2b51-4841-a826-9354d18681f4:image.png)

1. 클라이언트 → 프록시 호출
    
    사용자에 요청에 따라 컨트롤러가 호출되면, `@Transactional` 이 붙은 실제 서비스 객체가 아니라 **해당 서비스의 Spring AOP 프록시가 먼저 실행된다.**
    
    이 후 스프링 AOP 프록시의 내부에 있는 `TransactionInterceptor`가 실행된다.
    
    ![image.png](attachment:f7fb8801-81ff-4558-a6db-96e778309a5c:image.png)
    
2. 트랜잭션 속성 해석 (`TransactionDefinition` 결정)
    
    프록시가 메서드 호출을 받으면, `TransactionInterceptor`가 `@Transactional` 메타데이터를 읽어서 
    다음 정보를 담은 `TransactionDefinition`을 만든다
    
    ```java
    public interface TransactionDefinition {
        int getPropagationBehavior();   // 전파 옵션 (REQUIRED, REQUIRES_NEW 등)
        int getIsolationLevel();        // 격리 수준
        int getTimeout();               // 타임아웃
        boolean isReadOnly();           // 읽기 전용 여부
    }
    ```
    
3. 트랜잭션 시작/합류 결정 (`TransactionalManager` 호출)
    
    ```java
    TransactionStatus status =
            transactionManager.getTransaction(transactionDefinition);
    ```
    
    `TransactionInterceptor` 는 위 코드를 호출해 트랜잭션을 어떻게 할지 물어본다.
    
    - 없으면 새로 시작 : REQUIRED, REQUIRES_NEW, NESTED(저장점)
    - 있으면 합류/중단/예외 : 순서대로 REQUIRED, NOT_SUPPORTED, MANDATORY는 없으면 예외, NEVER는 있으면 예외
    
    **현재 스레드의 ThreadLocal에 Connection을 저장**
    
4. 비즈니스 로직 실행
5. 정상 종료 (commit)
    
    TransactionManager.commit() 처리
    
    커밋 전에  등록된 TransactionSynchronization callback이 실행된다
    
    ```java
    	TransactionSynchronization.beforeCommit()
    	transactionManager.commit(status)
    	TransactionSynchronization.afterCommit()
    ```
    
6. 예외 (rollback)
    
    롤백 규칙을 적용해 rollback 또는 commit을 결정한다
    
7. 정리 단계
    
    ```java
    TransactionSynchronization.afterCompletion()
    ```
    
    ThreadLocal 정리, JDBC Connection 반환
    

## 트랜잭션 롤백 케이스

```sql
Throwable
 ├── Error (시스템 오류, 애플리케이션이 처리 X)
 └── Exception
     ├── Checked Exception (Exception 하위, RuntimeException 제외)
     │     → IOException, SQLException, FileNotFoundException 등
     └── Unchecked Exception (RuntimeException 하위)
           → NullPointerException, IllegalStateException 등
```

- Spring의 기본 트랜잭션 정책은 **RuntimeException, Error에서 롤백**한다.
- `rollbackFor`, `noRollbackFor` 옵션을 통해 기본 정책을 변경할 수 있다.
    - RuntimeException이라도 롤백 안하도록, CheckedException이어도 롤백하도록
    
    ```java
    @Transactional(rollbackFor = IOException.class)
    public void pay() throws IOException {
        throw new IOException();   // ✅ 이제 롤백됨
    }
    ```
    

### **Checked Exception vs Unchecked Exception**

 **둘다 실행 중에 발생할 수 있으며, 차이는 발생 시점이 아니라 처리 방식에 있다**

Checked **Exception**

- 컴파일러가 처리를 강제함 (try-catch, throws)

Unchecked **Exception**

- 컴파일러가 체크하지 않음 (RuntimeException)
- 프로그래밍 오류에 가까운 예외

## 트랜잭션 전파 수준

### Propagation.REQUIRED

- 스프링 프레임워크 기본 전파 수준
- 현재 진행 중인 트랜잭션이 있다면 참여하고, 없다면 새로운 트랜잭션을 시작한다

### Propagation.REQUIRED_NEW

### Propagation.SUPPORTED

### Propagation.NOT_SUPPORTED

### Propagation.MANDATORY

### Propagation.NEVER

## 트랜잭셔널 어노테이션 인식 불가 케이스

- 같은 클래스 내부 호출은 안됨
    - 프록시 미실행
- 메서드가 public, protected 여야 함
